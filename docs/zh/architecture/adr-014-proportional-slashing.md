# ADR 14:比例削减

## 变更日志

- 2019-10-15:初稿
- 2020-05-25:删除了相关根削减
- 2020-07-01:更新以包含 S 曲线函数而不是线性函数

## 语境

在基于权益证明的链中，由于审查、活性失败、分叉攻击等风险的增加，将共识权力集中在一小部分验证者之间可能会对网络造成损害。网络，委托人不会直接感受到它为委托给已经很大的验证人做出贡献。我们希望有一种方法可以将中心化的负外部性成本转嫁给那些大型验证者及其委托人。

## 决定

### 设计

为了解决这个问题，我们将实施一个称为比例削减的程序。我们希望验证器越大，他们应该被削减的越多。第一个天真的尝试是使验证者的斜线百分比与其共识投票权的份额成正比。 

```
slash_amount = k * power//power is the faulting validator's voting power and k is some on-chain constant
```

然而，这将激励拥有大量权益的验证者在账户之间分配他们的投票权(女巫攻击)，这样如果他们出错，他们都会被削减到较低的百分比。 对此的解决方案是不仅要考虑验证者自己的投票百分比，还要考虑在指定时间范围内被削减的所有其他验证者的投票百分比。 

```
slash_amount = k * (power_1 + power_2 + ... + power_n)//where power_i is the voting power of the ith validator faulting in the specified time frame and k is some on-chain constant
```

现在，如果有人将一个 10% 的验证器分成两个 5% 的验证器，每个验证器都出错，那么他们都在同一时间范围内出错，他们都将被削减 10% 的金额。

然而，在实践中，我们可能不希望发生错误的权益数量与要削减的权益百分比之间存在线性关系。特别是，只有 5% 的股权双重签名实际上没有对安全造成重大威胁，而 30% 的股权有错显然值得大幅削减，因为非常接近 Tendermint 安全受到威胁的点。线性关系将需要这两者之间的 6 倍差距，而对网络构成的风险差异要大得多。我们建议使用 S 曲线(正式的[逻辑函数](https://en.wikipedia.org/wiki/Logistic_function)来解决这个问题)。 S 曲线很好地捕捉了所需的标准。它们允许对小值的削减因子最小，然后在某个阈值点附近迅速增长，在该点所构成的风险变得显着。 
#### 参数化

这需要参数化逻辑函数。很好地理解如何对此进行参数化。它有四个参数:

1) 最小削减系数
2) 最大削减系数
3)S曲线的拐点(本质上你想把S放在什么地方)
4) S 曲线的增长率(S 的拉长程度)

#### 非女巫验证器之间的相关性

人们会注意到，该模型不会区分由相同运营商运行的多个验证器与由不同运营商运行的验证器。这实际上可以看作是一个额外的好处。它激励验证者将他们的设置与其他验证者区分开来，以避免与他们相关的错误，否则他们将面临更高的削减风险。因此，例如，运营商应避免使用相同的流行云托管平台或使用相同的 Staking 作为服务提供商。这将导致一个更具弹性和去中心化的网络。

#### 悲伤

悲伤，故意让自己被砍伤以让别人的砍伤变得更糟的行为，在这里可能是一个问题。然而，使用这里描述的协议，攻击者也受到与受害者同等的悲痛影响，因此它不会给悲痛者带来太多好处。

### 执行

在 slashing 模块中，我们将添加两个队列来跟踪所有最近的 slash 事件。对于双符号故障，我们将“最近的斜线”定义为在最后一个“解除绑定期”内发生的斜线。对于活性错误，我们将“最近的斜线”定义为在最后一个“监禁期”内发生的斜线。 

```
type SlashEvent struct {
    Address                     sdk.ValAddress
    ValidatorVotingPercent      sdk.Dec
    SlashedSoFar                sdk.Dec
}
```

一旦这些斜线事件早于它们各自的“最近斜线周期”，就会从队列中删除它们。

每当出现新的斜线时，都会创建一个带有故障验证者投票百分比和 0 的 SlashEvent 结构。验证器同时在同一个队列中有多个 SlashEvents。

然后我们将迭代队列中的所有 SlashEvents，添加它们的 `ValidatorVotingPercent` 来计算新的百分比以使用上面介绍的“根总和的平方”公式来削减队列中的所有验证器。

一旦我们有了 `NewSlashPercent`，我们就再次遍历队列中的所有 `SlashEvent`，如果该 SlashEvent 的 `NewSlashPercent > SlashedSoFar`，我们将调用 `staking.Slash(slashEvent.Address, slashEvent.Power , Math.Min(Math.Max(minSlashPercent, NewSlashPercent - SlashedSoFar), maxSlashPercent)`(我们在任何斜线发生之前传递验证器的力量，以便我们削减正确数量的令牌)。然后我们设置`SlashEvent。 SlashedSoFar` 相当于 `NewSlashPercent`。
## Status

Proposed

## Consequences

### Positive

- 通过不鼓励委托给大型验证者来增加权力下放
- 激励验证者的去相关性
- 比意外故障更严厉地惩罚攻击
- 在削减率参数化方面更加灵活 

### Negative

- 比当前的实现更昂贵的计算。 将需要更多关于“最近的削减事件”的数据存储在链上。 
