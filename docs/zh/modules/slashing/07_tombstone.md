# 放样墓碑

## 摘要

在当前的 `slashing` 模块实现中，当共识引擎
通知状态机验证者的共识错误，验证者是
部分削减，并进入“监禁期”，在一段时间内，他们
不允许重新加入验证器集。但是，由于性质
共识错误和 ABCI，在发生违规之间可能会有延迟，
以及违规到达状态机的证据(这是其中之一
解绑期存在的主要原因)。

> 注意:tombstone 概念，仅适用于有延迟的故障
> 发生的违规行为和到达状态机的证据。例如，
> 验证者双重签名的证据可能需要一段时间才能到达状态机
> 由于不可预测的证据八卦层延迟和验证者的能力
> 选择性地显示双重签名(例如，对不常在线的轻客户端)。
> 另一方面，一旦出现活跃度削减，就会立即检测到
> 发生违规，因此不需要削减期。验证器是
> 立即入狱，不能再犯活体过错
> 直到他们出狱。未来可能还会出现其他类型的拜占庭断层
> 有延迟(例如，提交无效提案的证据作为交易)。
> 在实施时，必须决定这些未来类型的
> 拜占庭故障将导致墓碑(如果没有，斜线数量
> 不会受到削减期的限制)。

在目前的系统设计中，一旦验证者被投入监狱以达成共识
错误，在“JailPeriod”之后，他们被允许向“unjail”发送交易
自己，从而重新加入验证器集。

`slashing` 模块的“设计愿望”之一是，如果多个
在执行证据之前发生违规(并且验证者被投入监狱)，
他们应该只因一次最严重的违规行为而受到惩罚，而不是累积。
例如，如果事件序列是:

1. 验证者 A 提交违规 1(价值 30% 斜线)
2. 验证者 A 提交违规 2(价值 40% 斜线)
3. 验证者 A 提交违规 3(价值 35% 斜线)
4. 违规 1 的证据到达状态机(验证者被关进监狱)
5. 违规 2 的证据到达状态机
6. 违规 3 的证据到达状态机

只有违规 2 应使其斜线生效，因为它是最高的。这
完成，以便在验证者的共识密钥妥协的情况下，
即使黑客对许多块进行双重签名，他们也只会受到一次惩罚。
因为，解禁必须使用验证器的操作员密钥来完成，他们
有机会重新保护他们的共识密钥，然后表明他们是
准备好使用他们的操作员密钥。我们将这段时间称为仅跟踪
最大的违规，“削减期”。

一旦验证者通过出狱重新加入，我们就开始了新的削减期；
如果他们在出狱后犯下新的违规行为，它将被累计削减
上一罚单期间最严重的违规行为的顶部。

然而，虽然违规行为是根据惩罚期进行分组的，因为
证据可以在违规后提交至‘unbondingPeriod’，我们
仍然必须允许提交先前削减期的证据。
例如，如果事件序列是:

1. 验证者 A 提交违规 1(价值 30% 斜线)
2. 验证者 A 提交违规 2(价值 40% 斜线)
3. 违规 1 的证据到达状态机(并且验证者 A 被关进监狱)
4. 验证者 A 出狱 

我们现在处于新的削减期，但我们仍然要保持敞开大门
对于之前的违规行为，因为违规行为 2 的证据可能仍然存在。
随着削减周期数量的增加，它会产生更多的复杂性，因为我们有
跟踪每个罚单期间的最高违规金额。

> 注意:目前，根据`slashing`模块规范，一个新的slashing period
> 每次验证器解除绑定然后重新绑定时都会创建。这大概应该
> 更改为监禁/未监禁。见问题 [#3205](https://github.com/cosmos/cosmos-sdk/issues/3205)
> 了解更多详情。对于剩下的部分，我将假设我们只开始
> 当验证者被释放时，一个新的削减期。

slashing period 的最大数量是`len(UnbondingPeriod)/len(JailPeriod)`。
当前 Gaia 中 `UnbondingPeriod` 和 `JailPeriod` 的默认值为 3 周
和 2 天，分别。这意味着可能会有多达 11 次削减
每个验证器同时跟踪的时间段。如果我们设置`JailPeriod >= UnbondingPeriod`，
我们只需要跟踪 1 个削减期(即不必跟踪削减期)。

目前，在监狱期间的实施中，一旦验证人出狱，所有的
委派给他们的委派人(尚未解除绑定/重新委派)，
和他们在一起。鉴于共识安全错误如此严重
(比活性错误更重要)，让委托人不
“自动重新绑定”到验证器。

### 提案:无限监狱

我们建议为一个人设定“监禁时间”
提交共识安全错误的验证者，到“无限”(即墓碑状态)。
这实质上是将验证器踢出验证器集并且不允许
他们重新进入验证器集。他们所有的委托人(包括运营商自己)
必须解除绑定或重新授权。验证器操作员可以创建一个新的
验证器，如果他们愿意，可以使用新的操作员密钥和共识密钥，但他们
必须“重新赚回”他们的代表团。

实施墓碑制度，摆脱砍价期跟踪
将使 `slashing` 模块的方式更简单，特别是因为我们可以删除所有
`staking` 模块使用的 `slashing` 模块中定义的钩子
(`slashing` 模块仍然使用 `staking` 中定义的钩子)。

### 单次削减金额

另一个可以进行的优化是，如果我们假设所有 ABCI 故障
因为 Tendermint 共识被削减在同一水平，我们不必保持
跟踪“最大斜线”。一旦发生ABCI故障，我们就不必担心
比较潜在的未来以找到最大值。

目前唯一的 Tendermint ABCI 故障是:

- 不合理的预提交(双重符号)

目前计划在不久的将来包括以下故障:

- 在解除绑定阶段签署预提交(需要使轻客户端二分安全)

鉴于这些故障都是拜占庭故障，我们很可能会
想要平等地削减它们，因此我们可以制定上述更改。

> 注意:此更改可能对当前的 Tendermint 共识有意义，但也许
> 不适用于不同的共识算法或 Tendermint 的未来版本
> 可能要进行不同级别的惩罚(例如，部分削减)。 