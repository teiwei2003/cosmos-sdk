# IBCの概要

IBCとは何か、そのコンポーネント、およびユースケースを学びます。 {まとめ}

## ブロックチェーン間通信プロトコル(IBC)とは何ですか？

このドキュメントは、カスタムユースケース用に独自のIBCアプリケーションを作成したい開発者向けのガイドです。

IBCプロトコルのモジュラー設計は、IBCアプリケーション開発者が、クライアント、接続、およびアテステーションの検証の低レベルの詳細を深く理解する必要がないことを意味します。 アプリケーション開発者がIBCプロトコルの高レベルの理解を得ることができるように、スタックの下位レベルの簡単な説明が提供されます。

チャネルとポートの抽象化レイヤーの詳細は、アプリケーション開発者に関連しています。 独自のカスタムデータパッケージとIBCModuleコールバックを定義できます。

モジュールは、IBCを介して対話するために、次の要件を満たす必要があります。

- 1つ以上のポートにバインドします

- パケットデータを定義する

- オプションの確認構造とメソッドを定義して、それらをエンコードおよびデコードします

- IBCModuleインターフェイスを実装します

## コンポーネントの概要

このセクションでは、IBCコンポーネントとリポジトリリンクを紹介します。

### [クライアント](https://github.com/cosmos/ibc-go/blob/main/modules/core/02-client)

IBCクライアントは、一意のクライアントIDで識別されるライトクライアントです。 IBCのお客様は、他のブロックチェーンのコンセンサスステータス、およびお客様のコンセンサスステータスに基づいてプルーフを正しく検証するために必要なブロックチェーンのプルーフ仕様を追跡します。 クライアントは、複数のチェーン内の任意の数の接続に関連付けることができます。 サポートされているIBCクライアントは次のとおりです。

-[Solo Machineライトクライアント](https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/06-solomachine):携帯電話、ブラウザー、ラップトップなどのデバイス。
-[Tendermint Light Client](https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/07-tendermint):CosmosSDKに基づくチェーンのデフォルト値。
-[Localhost(loopback)client](https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/09-localhost):テスト、シミュレーション、およびアプリケーションへのデータパケットの中継に使用されます。同じモジュール。

### [接続](https://github.com/cosmos/ibc-go/blob/main/modules/core/03-connection)

Connectionsは、2つの[ConnectionEnd]オブジェクトを2つの独立したブロックチェーンにカプセル化します。 各[ConnectionEnd]は、別のブロックチェーン(カウンターパーティブロックチェーン)のクライアントに関連付けられています。 接続ハンドシェイクは、各チェーンのライトクライアントがそれぞれのカウンターパーティに対して正しいことを確認する役割を果たします。 接続が確立されると、IBCステータスのすべてのクロスチェーン検証を容易にする責任があります。 接続は、任意の数のチャネルに関連付けることができます。

### [証明](https://github.com/cosmos/ibc-go/blob/main/modules/core/23-commitment) 和 [路径](https://github.com/cosmos/ibc- go/blob/main/modules/core/24-host)

IBCでは、ブロックチェーンはネットワークを介して相互にメッセージを直接渡しません。

-通信するために、ブロックチェーンは、特定のメッセージタイプおよび特定のカウンターパーティ用に予約された正確に定義されたパスにいくつかの状態を送信します。 たとえば、ハンドシェイクの一部として特定のconnectionEndを格納するブロックチェーン、またはカウンターパーティチェーン上のモジュールに中継されることを目的としたデータパケット。

-リピータープロセスは、これらのパスの更新を監視し、パスの下に格納されているデータをデータの証明とともにカウンターパーティチェーンに送信することによってメッセージを中継します。

-すべてのIBC実装は、[ICS-24ホスト要件](https://github.com/cosmos/ics/tree/master/spec/core/ics-024-host-requirements)でIBCメッセージを送信するためのパスをサポートする必要があります。

-すべての実装で生成および検証する必要のある認証形式は、[ICS-23実装](https://github.com/confio/ics23)で定義されています。 

### [特徴](./ocap.md)

IBCは、モジュールが必ずしも相互に信頼しているとは限らない実行環境で動作するように設計されています。 IBCは、適切な権限を持つモジュールのみがチャネルを使用できるように、ポートとチャネルでのモジュールの動作を検証する必要があります。このセキュリティは、[動的機能](../architecture/adr-003-dynamic-capability-store.md)を使用して実現されます。ポートにバインドするとき、またはモジュールのチャネルを作成するとき、IBCは動的関数を返し、モジュールは使用するポートまたはチャネルを宣言する必要があります。このバインディング戦略は、他のモジュールが対応する機能を持たないため、他のモジュールがポートまたはチャネルを使用するのを防ぎます。

この説明は有用な背景情報ですが、IBCモジュールはこれらの低レベルの抽象化と対話する必要はまったくありません。 IBCアプリケーション開発者に関連する抽象化レイヤーは、チャネルとポートです。

IBCアプリケーションを別の**モジュール**として記述します。ブロックチェーン上のモジュールは、 `(channelID、portID)`タプルによって一意に識別されるチャネルを通過するデータパケットを送信、受信、および確認することにより、他のブロックチェーン上の他のモジュールと通信できます。

有用な例えは、IBCモジュールをコンピューター上のインターネットアプリケーションと考えることです。次に、チャネルをIP接続として概念化できます。IBCportIDはIPポートに似ており、IBCchannelIDはIPアドレスに似ています。 IBCモジュールの単一インスタンスは、同じポート上の他の任意の数のモジュールと通信でき、IBCは[(channelID、portID)]タプルを使用して、すべてのデータパケットを関連するモジュールに正しくルーティングします。各 `(portID <-> portID)`データパケットストリームを異なる一意のチャネルで送信することにより、IBCモジュールは複数のポートを介して別のIBCモジュールと通信することもできます。

### [ポート](https://github.com/cosmos/ibc-go/blob/main/modules/core/05-port)

IBCモジュールは、任意の数のポートにバインドできます。 各ポートは、一意の[portID]で識別される必要があります。 IBCは、同じ元帳で実行されている相互に信頼できないモジュールを通じてセキュリティを確保することを目的としているため、バインディングポートは動的オブジェクト関数を返します。 たとえば、特定のポートで操作を実行するには、そのポートIDを使用してチャネルを開くために、モジュールは動的オブジェクト関数をIBCハンドラーに提供する必要があります。 この要件は、悪意のあるモジュールが所有していないポートでチャネルを開くことを防ぎます。

IBCモジュールは、 `BindPort`に戻る機能を宣言する責任があります。

### [チャネル](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

2つのIBCポート間にIBCチャネルを確立できます。 1つのポートは1つのモジュールによって排他的に所有されます。 IBCパケットはチャネルを介して送信されます。 IPデータパケットに宛先IPアドレス、IPポート、送信元IPアドレス、および送信元IPポートが含まれているのと同様に、IBCデータパケットには宛先ポートID、チャネルID、送信元ポートID、およびチャネルIDが含まれています。 IBCデータパケットを使用すると、IBCはデータパケットをターゲットモジュールに正しくルーティングできると同時に、データパケットを受信するモジュールが送信側モジュールを認識できるようになります。

-チャネルは[ORDERED]にすることができるため、送信モジュールからのデータパケットは、送信された順序で受信モジュールによって処理される必要があります。

-送信モジュールからのデータパケットが到着した順序で処理されるように、チャネルを[順不同]にすることをお勧めします。これは、データパケットが送信される順序ではない場合があります。

モジュールは、通信するチャネルを選択できます。 IBCは、モジュールがチャネルハンドシェイク中に呼び出されるコールバックを実装することを期待しています。これらのコールバックは、カスタムチャネル初期化ロジックを実行できます。エラーが返された場合、チャネルハンドシェイクは失敗しています。コールバックでエラーを返すことにより、モジュールはプログラムでチャネルを拒否および受け入れることができます。

チャネルハンドシェイクは4ウェイハンドシェイクです。つまり、特定のチェーンAが確立された接続を使用して、チェーンBでチャネルを開く場合:

1. チェーンAは `ChanOpenInit`メッセージを送信して、チャネル初期化の試行をチェーンBに通知します。
2. チェーンBは `ChanOpenTry`メッセージを送信して、チェーンAのチャネルを開こうとします。
3. チェーンAは `ChanOpenAck`メッセージを送信して、チャネルの終了ステータスをオープンとしてマークします。
4. チェーンBは、チャネル終了ステータスをオープンとしてマークするために[ChanOpenConfirm]メッセージを送信します。

これらすべての操作が正常に行われると、チャネルは両側で開かれます。 ハンドシェイクの各ステップで、[ChannelEnd]に関連付けられたモジュールは、ハンドシェイクのそのステップのコールバックを実行します。 したがって、 `ChanOpenInit`で、チェーンAのモジュールはコールバック` OnChanOpenInit`を実行しました。

ポートに動的関数があるのと同様に、チャネル初期化モジュールは動的関数を宣言して、データパケットの送信など、チャネル操作を検証する関数を渡すことができるようにする必要があります。 チャネル関数は、ハンドシェイクの最初の部分でコールバックに渡されます。初期化チェーンの[OnChanOpenInit]または別のチェーンの[OnChanOpenTry]です。 

### [データパック](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

モジュールは、IBCチャネルでデータパケットを送信することによって相互に通信します。 すべてのIBCパケットには次のものが含まれます。

- 宛先 `portID`

- 宛先 `channelID`

- ソース `portID`

- ソース `channelID`

   これらのポートとチャネルにより、モジュールは特定のパケットの送信モジュールを知ることができます。

- シーケンスを強制的にソートすることを選択できます

- `TimeoutTimestamp`と `TimeoutHeight`

   ゼロ以外の場合、これらのタイムアウト値は、受信モジュールがパケットを処理する必要がある期限を決定します。

   データパケットを正常に受信せずにタイムアウトが経過した場合、送信モジュールはデータパケットをタイムアウトし、適切な対策を講じることができます。

モジュールは、IBCパケットの[データ[]バイト]フィールドでカスタムアプリケーションデータを相互に送信します。 パケットデータは、IBCハンドラーに対して完全に不透明です。 送信側モジュールは、アプリケーション固有のパケット情報をパケットの[データ]フィールドにエンコードする必要があります。 受信モジュールは、この[データ]をデコードして元のアプリケーションデータに戻す必要があります。

### [受信とタイムアウト](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

IBCは分散ネットワーク上で動作し、潜在的に障害のあるリピーターに依存して元帳間でメッセージを中継するため、IBCは、データパケットが時間内にまたはまったく宛先に配信されない状況を処理する必要があります。データパケットは、タイムアウトの高さまたはタイムアウトのタイムスタンプを指定する必要があります。指定すると、データパケットをターゲットチェーンで正常に受信できなくなります。

タイムアウトに達した場合、パケットを元のチェーンに送信してタイムアウトを証明し、元のチェーンがアプリケーション固有のロジックを実行してパケットをタイムアウトにすることができます。おそらく、パケットをロールバックして変更を送信します(ロックされているものはすべて返します)。送信者への資金、そしてすぐに)。

ORDEREDチャネルでは、チャネル内の1つのパケットがタイムアウトすると、チャネルが閉じられます。データパケットシーケンス[n]がタイムアウトした場合、シーケンス[k> n]のデータパケットは、送信された順序でデータパケットを処理するための順序付けられたチャネルコントラクトに違反せずに正常に受信できません。 ORDEREDチャネルはこの不変条件を適用するため、パケットnの指定されたタイムアウトに対してターゲットチェーンで受信されたシーケンスnの証拠は、パケットnをタイムアウトしてチャネルを閉じるのに十分ではありません。

UNORDEREDの場合、パケットは任意の順序で受信できます。 IBCは、UNORDEREDチャネルで受信したシーケンスごとにパケット受信を書き込みます。この受信には情報は含まれていません。これは単なるフラグであり、UNORDEREDチャネルが指定された順序でパケットを受信したことを示すことを目的としています。 UNORDEREDチャネルのデータパケットをタイムアウトにするには、指定されたタイムアウト期間内にデータパケットのシーケンスに対してデータパケットの受信がないことを証明する必要があります。もちろん、UNORDEREDチャネルのタイムアウトパケットは、そのパケットのアプリケーション固有のタイムアウトロジックをトリガーし、チャネルは閉じられません。

したがって、UNORDEREDチャネルを使用するほとんどのモジュールを使用することをお勧めします。これは、そのチャネルのユーザーに対して効果的に実行するために必要なアクティビティ保証が少ないためです。

### [ありがとう](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

データパケットを処理するとき、モジュールはアプリケーション固有の確認も書き込みます。確認できます:

-モジュールがIBCモジュールからデータパケットを受信した直後にデータパケットを処理する場合、モジュールは `OnRecvPacket`で同期します。

-モジュールがデータパケットを受信した後のある時点でデータパケットを処理する場合、それは非同期になります。

この確認データは、データパケット[Data]と同様にIBCに対して不透明であり、IBCでは単純なバイト文字列[[] byte]として扱われます。受信機モジュールは、送信機モジュールがそれを正しくデコードできるように、その確認応答をエンコードする必要があります。確認をエンコードする方法は、チャネルハンドシェイク中のバージョンネゴシエーションによって決定する必要があります。

確認は、パケット処理の成功または失敗、および送信側モジュールが適切なアクションを実行できるようにする追加情報をエンコードできます。

チェーン書き込み確認を受信した後、リピーターは確認を元の送信側モジュールに中継し、確認されたコンテンツを使用してアプリケーション固有の確認ロジックを実行します。この確認には、確認に失敗した場合(返金送信者)にパケット配信の変更をロールバックすることが含まれる場合があります。

元の送信者チェーンで確認を正常に受信した後、IBCモジュールは、対応するパケットプロミスが不要になったため、それを削除します。

## さらに読むと仕様

IBCの詳細については、次の仕様を確認してください。

-[IBC仕様](https://github.com/cosmos/ibc/tree/master/spec)
-[Cosmos SDKのIBCプロトコル](https://github.com/cosmos/ibc-go/tree/main/docs)

## 次へ{hide}

IBCをアプリケーションに[統合](./integration.md)する方法を学ぶ{hide}
