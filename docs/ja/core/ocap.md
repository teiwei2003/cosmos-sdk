# Object-Capability Model

## Intro

セキュリティを検討するときは、特定の脅威モデルから始めるのが最善です。私たちの脅威モデルは次のとおりです。

>繁栄しているCosmosSDKモジュールエコシステムは、ブロックチェーンアプリケーションに簡単に組み合わせることができ、欠陥のあるモジュールや悪意のあるモジュールが含まれていると想定しています。

CosmosSDKは
オブジェクト機能システムの基盤。

>オブジェクト機能システムの構造的特徴は
>コード設計のモジュール化と確実化
>コードの実装。
>>
>これらの構造的特徴は、いくつかの分析に役立ちます
>オブジェクト対応のプロシージャまたは操作のセキュリティ属性
>システム。それらのいくつか-特に情報フロー属性
> —オブジェクトで参照でき、
>コードの知識や分析に依存しない接続性
>オブジェクトの動作を決定します。
>>
>したがって、これらのセキュリティ属性を確立できます
>そして未知のものを含む新しいオブジェクトの存在下で維持する
>そして悪意のあるコードの可能性。
>>
>これらの構造的特徴は、2つの管理ルールから派生しています
>既存のオブジェクトへのアクセス:
>>
> 1.オブジェクトAがオブジェクトAを保持している場合にのみ、オブジェクトAはBにメッセージを送信できます。
> Bを参照してください。
> 2。オブジェクトAはCへの参照のみを取得できます
>オブジェクトAがCへの参照を含むメッセージを受信した場合。として
>これらの2つのルールの結果として、オブジェクトは参照を取得できます
>別のオブジェクトへの既存の参照チェーンを介してのみ。
>要するに、[接続のみが接続を生成します。]

オブジェクト機能の概要については、この[Wikipediaの記事](https://en.wikipedia.org/wiki/Object-capability_model)を参照してください。

## 実際のOcaps

アイデアは、作業を完了するために必要なものだけを明らかにすることです。

たとえば、次のコードスニペットはオブジェクト関数に違反しています
原則として:

```go
type AppAccount struct {...}
account := &AppAccount{
    Address: pub.Address(),
    Coins: sdk.Coins{sdk.NewInt64Coin("ATM", 100)},
}
sumValue := externalModule.ComputeSumValue(account)
```

`ComputeSumValue`メソッドは純粋関数を意味しますが、暗黙的です
ポインタ値を受け入れる機能は、値を変更する機能です。
価値。 優先メソッドのシグネチャをコピーに変更する必要があります。 

```go
sumValue := externalModule.ComputeSumValue(*account)
```

Cosmos SDKでは、この原則の適用を確認できます。
Gaiaアプリ。

+++ https://github.com/cosmos/cosmos-sdk/blob/v0.41.4/simapp/app.go#L249-L273

次の図は、キーパー間の現在の依存関係を示しています。

！[キーパーの依存関係](../uml/svg/keeper_dependencies.svg)

## 次へ{hide}

[`runTx`ミドルウェア](./runtx_middleware.md){hide}を理解する