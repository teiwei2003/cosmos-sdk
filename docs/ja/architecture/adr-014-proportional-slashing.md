# ADR 14:比率の削減

## 変更ログ

-2019-10-15:最初のドラフト
-2020-05-25:関連するルートカットを削除しました
-2020-07-01:線形関数の代わりにSカーブ関数を含めるように更新

## 環境

権利の証明に基づくチェーンでは、検閲、ライブネス障害、分岐攻撃などのリスクが高まるため、少数の検証者にコンセンサスパワーを集中させると、ネットワークに損傷を与える可能性があります。 ネットワーク、委任者は、それがすでに大きな検証者への委任に貢献していると直接感じることはありません。 中央集権化の負の外部性コストをそれらの大規模なバリデーターとその委任者に転嫁する方法があることを願っています。

## 決定

### 設計

この問題を解決するために、比例縮小と呼ばれる手順を実装します。 バリデーターが大きいほど、より多くのバリデーターを削減する必要があります。 最初の素朴な試みは、検証者のスラッシュのパーセンテージをコンセンサス投票権のシェアに比例させることです。 

```
slash_amount = k * power//power is the faulting validator's voting power and k is some on-chain constant
```

ただし、これにより、大きな利害関係を持つ検証者がアカウント間で投票権を分配するように動機付けられ(魔女の攻撃)、ミスを犯した場合、すべての検証者の割合が低くなります。 これに対する解決策は、検証者自身の投票率を考慮するだけでなく、指定された時間枠内に削減された他のすべてのバリデーターの投票率も考慮することです。 

```
slash_amount = k * (power_1 + power_2 + ... + power_n)//where power_i is the voting power of the ith validator faulting in the specified time frame and k is some on-chain constant
```

ここで、誰かが10％のバリデーターを2つの5％のバリデーターに分割し、それぞれがミスを犯した場合、それらはすべて同じ時間枠でミスを犯し、すべて10％削減されます。

ただし、実際には、誤ったエクイティの量とエクイティの割合を減らすことの間の線形関係を望まない場合があります。特に、エクイティのわずか5％の二重署名は、実際にはセキュリティに大きな脅威をもたらすことはなく、エクイティの30％のエラーは、テンダーミントのセキュリティのポイントに非常に近いため、明らかに大幅に削減する価値があります。脅かされています。線形関係では、2つの間に6倍のギャップが必要になり、ネットワークへのリスクにははるかに大きな違いがあります。この問題を解決するには、Sカーブ(公式には[論理関数](https://en.wikipedia.org/wiki/Logistic_function))を使用することをお勧めします。 Sカーブは、必要な標準を非常によく捉えています。それらは、小さな値の減少係数を最小化することを可能にし、その後、もたらされるリスクが重要になる特定のしきい値ポイントの近くで急速に成長します。
パラメータ化する####

これには、パラメーター化された論理関数が必要です。これをパラメータ化する方法をよく理解している。 4つのパラメータがあります。

1)最小削減係数
2)最大削減係数
3)S曲線の変曲点(基本的にSを置きたい場所)
4)S曲線の成長率(Sの伸び度)

#### 非魔女バリデーター間の相関

モデルは、同じオペレーターによって実行される複数のバリデーターと、異なるオペレーターによって実行されるバリデーターを区別しないことに気付くでしょう。これは実際には追加のメリットと見なすことができます。バリデーターが他のバリデーターと設定を区別して、それらに関連するエラーを回避するように促します。そうしないと、バリデーターが削減されるリスクが高くなります。したがって、たとえば、事業者は、同じ人気のあるクラウドホスティングプラットフォームを使用したり、サービスプロバイダーと同じステーキングを使用したりすることは避けてください。これにより、より回復力のある分散型ネットワークが実現します。

#### 悲しい

ここでは、他人のチョップを悪化させるために故意に自分をチョップする行為である哀悼が問題になる可能性があります。ただし、ここで説明するプロトコルを使用すると、攻撃者は被害者と同じ悲しみの影響も受けるため、悲しみに暮れる人にはあまりメリットがありません。

### 埋め込む

スラッシュモジュールでは、最近のすべてのスラッシュイベントを追跡するために2つのキューを追加します。ダブルシンボル障害の場合、[最近のスラッシュ]は、最後の[バインド解除期間]中に発生したスラッシュとして定義されます。活気エラーについては、[最近のスラッシュ]を最後の[投獄期間]中に発生したスラッシュと定義します。  

```
type SlashEvent struct {
    Address                     sdk.ValAddress
    ValidatorVotingPercent      sdk.Dec
    SlashedSoFar                sdk.Dec
}
```

これらのスラッシュイベントがそれぞれの[最近のスラッシュ期間]よりも早くなると、キューから削除されます。

新しいスラッシュが表示されるたびに、失敗したバリデーターの投票率が0であるSlashEvent構造が作成されます。バリデーターには、同じキューに同時に複数のSlashEventがあります。

次に、キュー内のすべてのSlashEventを繰り返し、それらのValidatorVotingPercentを追加して、上記で紹介した[ルート合計の2乗]式を使用して、キュー内のすべてのバリデーターを減らす新しいパーセンテージを計算します。

`NewSlashPercent`を取得したら、キュー内のすべての` SlashEvent`を再度トラバースします。SlashEventの `NewSlashPercent> SlashedSoFar`の場合、` staking.Slash(slashEvent.Address、slashEvent.Power、Math.Min(Math .Max(minSlashPercent、NewSlashPercent-SlashedSoFar)、maxSlashPercent) `(正しい数のトークンをカットできるように、スラッシュが発生する前にバリデーターのパワーを渡します)。次に、`SlashEvent。SlashedSoFar`を `と同等に設定します。 NewSlashPercent`。
## 状態

提案

## 結果

### ポジティブ

-大規模なバリデーターへの委任を阻止することにより、分散化を促進します
-バリデーターのインセンティブ非相関
-偶発的な失敗よりも厳しく攻撃を罰する
-削減率のパラメータ化における柔軟性の向上

### ネガティブ

-現在の実装よりも高価な計算。チェーンの[最近のカット]に関するより多くのデータを保存します。 