# ADR 040:ストレージとSMT状態のコミットメント

## 変更ログ

-2020-01-15:ドラフト

## 状態

ドラフトは実装されていません

## 概要

スパースマーケルツリー([SMT](https://osf.io/8mcnh/))は、さまざまなストレージとパフォーマンスの最適化を備えたバージョンのマーケルツリーです。このADRは、州のコミットメントとデータストレージの分離、およびCosmosSDKのIAVLからSMTへの変換を定義します。

## 環境

現在、Cosmos SDKはステータス[コミットメント](https://cryptography.fandom.com/wiki/Commitment_scheme)とデータストレージにIAVLを使用しています。

IAVLは、事実上Cosmosエコシステムで孤立したプロジェクトになり、非効率的な州のコミットメントデータ構造であることが証明されています。
現在の設計では、IAVLはデータストレージと状態コミットメントのMerkelツリーに使用されます。 IAVLは、独立したMerkelized Key .Valueデータベースを目指していますが、KVデータベースエンジンを使用してすべてのツリーノードを格納します。したがって、各ノードはKVDBの個別のレコードに格納されます。これは多くの非効率性と問題を引き起こします:

+すべてのオブジェクトクエリは、ルートからツリーをトラバースする必要があります。同じオブジェクトに対する後続のクエリは、CosmosSDKレベルでキャッシュされます。
+各エッジトラバーサルにはDBクエリが必要です。
+スナップショットを作成します[高価](https://github.com/cosmos/cosmos-sdk/issues/7215#issuecomment-684804950)。 100 MB未満の状態をエクスポートするのに約30秒かかります(2020年3月現在)。
+ IAVLの更新により、ツリーの再編成とO(log(n))ハッシュの再計算がトリガーされる可能性があり、これがCPUのボトルネックになる可能性があります。
+ノード構造は非常に高価です。標準のツリーノード要素(キー、値、左および右の要素)と、高さやバージョン(Cosmos SDKでは不要)などの追加のメタデータが含まれています。ノード全体をハッシュし、基になるデータベースのキーとしてハッシュを使用します[ref](https://github.com/cosmos/iavl/blob/master/docs/node/node.md
)。

さらに、IAVLプロジェクトにはサポートとメンテナーが不足しており、より優れた完全な代替案が見られました。 IAVLは最適化されていませんが、ストレージと状態の約束を達成するための他のソリューションを検討しています。

## 決定

コンセンサスに必要な状態コミットメント(** SC **)とステートマシンに必要な状態ストレージ(** SS **)のフォーカスを分離することをお勧めします。最後に、IAVLを[CelestiaのSMT](https://github.com/lazyledger/smt)に置き換えます。 Celestia SMTはDiem(クラゲと呼ばれる)設計に基づいています[*]-デフォルト値のみのサブツリーを単一ノードで置き換えることにより(Ethereum2は同じ方法を使用します)、計算上最適化されたSMTを使用し、コンパクトな証明を実現します。

ここで説明するストレージモデルは、データ構造やシリアル化を扱いません。これはキーと値のデータベースであり、キーと値はバイナリファイルです。ストレージユーザーは、データのシリアル化を担当します。 

### 状態の約束をストレージから分離する

ストレージとコミットメントを(SMTを介して)分離することで、さまざまなコンポーネントをその使用法とアクセスパターンに基づいて最適化できます。

`SC`(SMT)は、データを送信し、マークル証明を計算するために使用されます。 `SS`はデータに直接アクセスするために使用されます。競合を回避するために、 `SS`と` SC`の両方が別々のストレージ名前空間を使用します(以下で同じデータベースを使用できます)。 `SS`は各レコードを直接保存します(`(key、value) `を` key→value`にマップします)。

SMTはMerkelツリー構造です。キーを直接保存しません。 `(key、value)`ペアごとに、 `hash(key)`がリーフパスとして使用され(キーをハッシュしてツリー内の葉を均等に分散します)、 `hash(value)`はリーフコンテンツです。 [以下](#smt-for-state-commitment)は、ツリー構造をより詳細に指定します。

データアクセスには、2つの追加のKVバケットを使用することをお勧めします(キーと値のペアの名前空間として実装され、[列ファミリー](https://github.com/facebook/rocksdb/wiki/Terminology)と呼ばれることもあります):

1. B1: `key→value`:Cosmos SDK` KVStore`インターフェースの背後にあるステートマシンによって使用されるメインオブジェクトストレージ:直接キーアクセスを提供し、プレフィックスの反復を許可します(KV DBバックエンドがサポートする必要があります)。
2. B2: `hash(key)→key`:SMTパスからキーの逆インデックスを取得します。内部的には、SMTは `(key、value)`を `prefix || hash(key)|| hash(value)`として保存します。したがって、 `hash(key)→B2→B1`を組み合わせることでオブジェクト値を取得できます。
3.必要に応じて、より多くのバケットを使用してアプリケーションの使用を最適化できます。

[SS]と[SC]にはKVデータベースの使用をお勧めします。ストレージインターフェイスでは、[SS]と[SC]に同じ物理データベースバックエンドと2つの別々のデータベースを使用できます。後者のオプションでは、 `SS`と` SC`を異なるハードウェアユニットに分離して、より複雑なセットアップシナリオをサポートし、全体的なパフォーマンスを向上させることができます。異なるバックエンド(RocksDBやBadgerなど)を使用でき、最下層を個別に調整できます。データベース構成。

### 要件

州の保管要件:

+範囲クエリ
+高速(キー、値)アクセス
+スナップショットを作成する
+履歴バージョン
+剪定(ガベージコレクション)

国家のコミットメント要件:

+クイックアップデート
+ツリーパスは短くする必要があります
+ ICS-23標準を使用して、過去のコミットメント証明書を照会します
+剪定(ガベージコレクション)

### National Commitment SMT

スパースなマークルツリーは、扱いにくいサイズの完全なマークルツリーのアイデアに基づいています。ここでの前提は、ツリーのサイズを処理するのが難しいため、ツリーのサイズに比べて有効なデータブロックを持つリーフノードが数個しかないため、まばらなツリーが表示されることです。

完全な仕様は[Celestia](https://github.com/celestiaorg/celestia-specs/blob/ec98170398dfc6394423ee79b00b71038879e211/src/specs/data_structures.md#sparse-merkle-tree)にあります。要するに:

* SMTは、[Certificate Transparency(RFC-6962)](https://tools.ietf.org/html/rfc6962)で説明されているのと同じ方法で構築された、バイナリMerkleツリーで構成されていますが、ハッシュ関数SHAとして使用されます。 -2-256、[FIPS 180-4](https://doi.org/10.6028/NIST.FIPS.180-4)で定義されています。
※リーフノードと内部ノードのハッシュ方式が異なります。リーフノードの前面に1バイトの[0x00]が追加され、内部ノードの前面に[0x01]が追加されます。
*空のリーフノードにデフォルト値を割り当てます。
*上記のルールは、空のサブツリーのルートである中間ノードの値を事前に計算するのに十分ですが、さらに単純化すると、このデフォルト値を空のサブツリーのルートであるすべてのノードに拡張できます。デフォルト値として32バイトのゼロが使用されます。このルールは、上記のルールよりも優先されます。
*空でないリーフを含むサブツリーのルートである内部ノードは、そのリーフのリーフノードに置き換えられます。

### ストレージ同期と状態バージョン管理のためのスナップショット

以下では、単に_snapshot_によって、_ABCIスナップショット同期_ではなく、データベーススナップショットメカニズムを参照しています。後者は_snapshotsync_と呼ばれます(以下で説明するように、データベーススナップショットが直接使用されます)。

データベーススナップショットは、特定の時間またはトランザクションにおけるデータベースの状態のビューです。データベースの完全なコピーではありません(大きすぎます)。通常、スナップショットメカニズムは_コピーオンライト_に基づいており、特定の段階でDBステータスを効果的に転送できます。
一部のデータベースエンジンはスナップショットをサポートしています。したがって、状態の同期とバージョン管理(以下で説明)にこの機能を再利用することをお勧めします。サポートされているデータベースエンジンは、スナップショットを効果的に実装するものに限定しています。最後のセクションでは、評価されたDBについて説明します。

Stargateのコア機能の1つは、 `.snapshot`パッケージで提供される_snapshotsync_です。これは、信頼せずに、すべてのトランザクションを繰り返さずにブロックチェーンを同期する方法を提供します。この機能はCosmosSDKに実装されており、ストレージのサポートが必要です。現在、サポートされているバックエンドはIAVLのみです。これは、特定のバージョンの[SS]のスナップショットをヘッダーチェーンとともにクライアントにストリーミングすることで機能します。

新しいデータベーススナップショットが各[EndBlocker]に作成され、ブロックの高さで識別されます。 `root`は、利用可能なスナップショットを保存および追跡して、` SS`の特定のバージョンを提供します。 `root`ストアは、以下で説明する` RootStore`インターフェースを実装します。基本的に、 `RootStore`は` Committer`インターフェースをカプセル化します。 `Committer`には、スナップショットを作成および削除するための` Commit`、 `SetPruning`、および` GetPruning`関数があります。 `rootStore.Commit`関数は、新しいスナップショットを作成し、呼び出されるたびにバージョンをインクリメントし、古いバージョンを削除する必要があるかどうかを確認します。 `コミッター`インターフェースを実装するためにSMTインターフェースを更新する必要があります。
注:各ブロックは、 `Commit`を1回だけ呼び出す必要があります。そうしないと、バージョン番号とブロックが高度に同期するリスクに直面する可能性があります。
注:Cosmos SDKストレージの場合、インターフェイスを `Committer`と` PruningCommitter`に分割することを検討できます。マルチルートのみが `PruningCommitter`を実装する必要があります(キャッシュとプレフィックスストレージをトリミングする必要はありません)。

`abci.RequestQuery`と状態同期スナップショットの履歴バージョン番号は、チェーン構成(ブロックチェーンコンセンサスによって暗示される構成)ではなく、ノード構成の一部です。構成では、過去のブロックの数と特定の数を法として過去のブロックの数を指定できる必要があります(たとえば、過去100ブロックと過去2000ブロックの100ブロックごとのスナップショット)。アーカイブノードは、過去のすべてのバージョンを保持できます。

古いスナップショットのプルーニングは、データベースによって効果的に実行されます。 `SC`のレコードを更新するときはいつでも、SMTはノードを更新しません-古いノードを削除する代わりに、更新パス上に新しいノードを作成します。各ブロックのスナップショットを取得しているため、データベースから孤立したノードをすぐに削除するようにメカニズムを変更する必要があります。これは安全な操作です。スナップショットはレコードを追跡し、過去のバージョンにアクセスするときに利用できるようにします。

アクティブなスナップショットを管理するために、DB _スナップショットの最大数_オプション(使用可能な場合)を使用するか、[EndBlocker]のDBスナップショットを削除します。ブロックの高さでスナップショットを識別し、ストレージ関数を呼び出して過去のバージョンを削除することにより、後者のオプションを効果的に完了することができます。

#### 古いステータスバージョンにアクセス

機能要件の1つは、古い状態にアクセスすることです。これは、[abci.RequestQuery]構造を介して行われます。バージョンはブロックの高さで指定されます(したがって、ブロックの高さ[H]でキー[K]を使用してオブジェクトを照会します)。 `abci.RequestQuery`でサポートされている古いバージョンの数は構成可能です。古い状態へのアクセスは、利用可能なスナップショットを使用して行われます。
`prove = true`パラメータが設定されていない限り、` abci.RequestQuery`は `SC`の古い状態を必要としません。 `SC`と` SS`の両方に要求されたバージョンのスナップショットがある場合にのみ、SMTMerkel証明書を `abci.ResponseQuery`に含める必要があります。

さらに、Cosmos SDKは、履歴状態に直接アクセスする方法を提供できます。ただし、ステートマシンはこれを行うべきではありません。スナップショットの数は構成可能であるため、非決定論的な実行につながります。

評価したデータベースの古い状態をクエリするためのバージョン管理とスナップショットのメカニズムを積極的に[確認](https://github.com/cosmos/cosmos-sdk/discussions/8297)します。

### ステータスの証明

状態ストア(SS)に格納されているオブジェクトの場合、対応するオブジェクトが[SC]にあります。キー[K]で識別されるオブジェクト[V]の証明は[SC]のブランチであり、パスはキー[hash(K)]に対応し、リーフは[hash(K、V)]です。

### ロールバック

トランザクションが失敗した場合は、トランザクションを処理してステータスの更新をロールバックできる必要があります。これは、次の方法で実行できます。トランザクション中に、すべての状態変更要求(書き込み)を[CacheWrapper]抽象化に保存します(今日と同じように)。ブロック処理が終了したら、[Endblocker]でルートストレージを送信します。その時点で、すべての変更がSMTと[SS]に書き込まれ、スナップショットが作成されます。

### オブジェクトを保存せずに送信する

モジュールがオブジェクト自体ではなくオブジェクトpromiseを保存する必要があるユースケースを特定しました。クライアントが複雑なオブジェクトを受け取ることがあり、ストレージレイアウトを知らないと、オブジェクトの正確さを証明できません。これらのユースケースでは、オブジェクトを直接保存せずに送信する方が簡単です。

### マルチストアのリファクタリング

Stargateの `.store`実装(store .v1)は、追加のレイヤー(` MultiStore`構造)をSDKストレージビルドに追加します。マルチストアは、Cosmos SDKのモジュール性をサポートするために存在します。各モジュールは独自のIAVLインスタンスを使用しますが、現在の実装では、すべてのインスタンスが同じデータベースを共有します。ただし、後者は、実装が真のモジュール性を提供しないことを示しています。代わりに、競合状態とアトミックデータベースの送信に関連する問題が発生します([\#6370](https://github.com/cosmos/cosmos-sdk/issues/6370)および[ディスカッション](https://を参照)。 github.com)。com.cosmos .cosmos-sdk .discussions .8297#discussioncomment-757043))。

SDKで複数のストレージの概念を減らし、[RootStore]オブジェクトで[SC]と[SS]の単一インスタンスを使用することをお勧めします。混乱を避けるために、 `MultiStore`インターフェースの名前を` RootStore`に変更する必要があります。 `RootStore`には次のインターフェースがあります。簡潔にするために、トラッキングとリスナーを構成する方法は省略されています。  

```go
/.Used where read-only access to versions is needed.
type BasicRootStore interface {
    Store
    GetKVStore(StoreKey) KVStore
    CacheRootStore() CacheRootStore
}

/.Used as the main app state, replacing CommitMultiStore.
type CommitRootStore interface {
    BasicRootStore
    Committer
    Snapshotter

    GetVersion(uint64) (BasicRootStore, error)
    SetInitialVersion(uint64) error

    .....Trace and Listen methods
}

/.Replaces CacheMultiStore for branched state.
type CacheRootStore interface {
    BasicRootStore
    Write()

    .....Trace and Listen methods
}

/.Example of constructor parameters for the concrete type.
type RootStoreConfig struct {
    Upgrades        *StoreUpgrades
    InitialVersion  uint64

    ReservePrefix(StoreKey, StoreType)
}
```

<!-- TODO: 查看是否可以进一步减少或简化这些类型 -->
<!-- TODO: RootStorePersistentCache 类型 -->

[MultiStore]とは異なり、[RootStore]では、サブストアを動的にマウントしたり、単一のサブストアにバックアップデータベースを提供したりすることはできません。

注:モジュールは、特別なPromiseと独自のデータベースを使用できるようになります。例:州にZK認定を使用するモジュールは、この認定を `RootStore`(通常は単一のレコードとして)に保存して送信し、専用ストレージをプライベートに管理するか、` SC`低レベルインターフェイスを使用して管理できます。

#### 互換性のサポート

ユーザーがこの新しいインターフェースに簡単に移行できるようにするために、[CommitMultiStore]をラップするが[CommitRootStore]インターフェースを提供し、基になる[CommitMultiStore]を安全に作成してアクセスするための関数を公開するシムを作成できます。

新しい `RootStore`とサポートタイプを` store .v2`パッケージに実装して、既存のコードを壊さないようにすることができます。

#### メルケルプルーフとIBC

現在、IBC(v1.0)マークル証明パスは2つの要素( `[" <store-key> "、" <record-key> "]`)で構成されており、各キーは個別の証明に対応しています。これらはすべて、個人の[ICS-23仕様](https://github.com/cosmos/ibc-go/blob/f7051429e1cf833a6f65d51e6c3df1609290a549/modules/core/23-commitment/types/merkle.go#L17)に従って検証されています。ルートコミットハッシュが取得されるまで、ハッシュは次のステップでコミット値として使用されます。
`" <record-key> "`の証明書のルートハッシュは、アプリケーションハッシュを検証するために `" <store-key> "`でハッシュされます。

これは、すべてのレコードを単一のMerkleツリー構造に格納し、ストレージキーとレコードキーに対して個別の証明を生成しない[RootStore]とは互換性がありません。理想的には、プルーフのストレージキーコンポーネントを省略して、[操作なし]仕様を使用するように更新できるため、レコードキーのみが使用されます。ただし、IBC検証コードは `" ibc "`プレフィックスをハードコードし、それを認証パスの個別の要素としてSDK認証に適用するため、これは大きな変更なしでは不可能です。この動作を破ると、IBCモジュールを広く採用しているCosmosエコシステムに深刻な影響を及ぼします。 IBCモジュールを更新するためのクロスチェーン要求は、時間のかかる作業であり、実装するのは簡単ではありません。

回避策として、[RootStore]は2つの別々のSMTを使用する必要があります(1つは同じ基になるデータベースを使用できます)。1つはIBC状態用で、もう1つはその他すべて用です。これらのSMTを参照する単純なMerkleマップは、最終的なアプリハッシュを作成するためのMerkleツリーとして機能します。 MerkleマッピングはDBに保存されません-実行時に構築されます。 IBCサブストレージキーは[ibc]である必要があります。

回避策は引き続きアトミック同期を保証できます。[提案されたデータベースバックエンド](#evaluated-kv-databases)は、コミットフェーズ中に使用されるアトミックトランザクションと効率的なロールバックをサポートします。

提案されたソリューションは、IBCモジュールが完全にアップグレードされて単一要素のコミットメントの証明をサポートするまで使用できます。

### 最適化:モジュールキープレフィックスを圧縮

モジュールキーから整数へのマッピングを作成し、varintエンコーディングを使用して整数をシリアル化することにより、プレフィックスキーを圧縮することを検討します。バリントエンコーディングは、異なる値に共通のバイトプレフィックスがないことを保証します。マークル証明の場合、プレフィックス圧縮を使用できないため、 `SS`キーに対してのみ機能するはずです。さらに、プレフィックス圧縮はモジュール名前空間にのみ適用する必要があります。すなわち:

+各モジュールには独自の名前空間があります。
+モジュールの名前空間にアクセスするときに、プレフィックスが埋め込まれたKVStoreを作成します。
+プレフィックスは、[SS]にアクセスして管理する場合にのみ圧縮されます。

コードが変更されないようにする必要があります。静的変数(アプリケーションによって提供される)またはSS状態のマッピングを特別なキーで修正できます。

TODO:キーの圧縮を決定する必要があります。
## 最適化:SSキー圧縮

一部のオブジェクトは、Protobufメッセージタイプを含むキーで保存される場合があります。そのような鍵は非常に長いです。 Protobufメッセージタイプをvarintにマッピングできれば、多くのスペースを節約できます。

TODO:この操作を完了するか、別のADRに移動します。

## 結果

### 下位互換性

このADRでは、CosmosSDKレベルのAPIの変更は導入されません。

ステートマシンのストレージレイアウトを変更し、これらの変更をマージするためにストレージハードフォークとネットワークのアップグレードが必要でした。 SMTはメルケル認証機能を提供しますが、ICS23とは互換性がありません。 ICS23互換性の証明を更新する必要があります。

### ポジティブ

+州と州のコミットメントを切り離すことで、さらなる最適化とより優れたストレージモデルのためのより優れたエンジニアリングの機会がもたらされます。
+パフォーマンスの向上。
+ IAVLよりも広く採用されていることが証明されているSMTベースのキャンプに参加してください。 SMTの採用を決定したサンプルプロジェクト:Ethereum2、Diem(Libra)、Trillan、Tezos、Celestia。
+マルチストアの削除により、現在のマルチストア設計の長期的な問題が修正されます。
+簡略化されたメルケル証明— IBCを除いて、すべてのモジュールには1つのメルケル証明しかありません。

### ネガティブ

+ストレージの移行
+ LLSMTはプルーニングをサポートしていません-この機能を追加してテストする必要があります。
+ `SS`キーにはキープレフィックスのオーバーヘッドがあります。 `SC`のすべてのキーは同じサイズ(ハッシュされている)であるため、これは` SC`には影響しません。

### ニュートラル

+ Cosmosホワイトペーパーの主要な提案の1つであるIAVLを廃止します。

## 代替デザイン

ほとんどの代替設計は、[State Commitments and Storage Report](https://paper.dropbox.com/published/State-commitments-and-storage-review--BDvA1MLwRtOx55KRihJ5xxLbBw-KeEB7eOd11pNrZvVtqUgL3h)で評価されています。

イーサリアムの調査が公開されました[VerkleTrie](https://dankradfeist.de/ethereum/2021/06/18/verkle-trie-for-eth1.html)-多項式のコミットメントをメルケルツリーと組み合わせて、ツリーのアイデアの高さを減らします。このコンセプトには大きな可能性がありますが、実装するには時期尚早だと思います。他の研究で必要なすべてのライブラリが実装されると、現在のSMTベースの設計をVerkleTrieに簡単に更新できます。このADRで説明されている設計の主な利点は、状態の約束をデータストレージから分離し、より強力なインターフェイスを設計することです。

## さらなる議論

### 評価されたKVデータベース

スナップショットのサポートを評価するために使用される既存のデータベースKVデータベースを検証しました。次のデータベースは、効率的なスナップショットメカニズムを提供します:Badger、RocksDB、[Pebble](https://github.com/cockroachdb/pebble)。このようなサポートを提供していない、または本番環境の準備ができていないデータベース:boltdb、leveldb、goleveldb、membdb、lmdb。

### リレーショナルデータベース

状態を保存するには、単純なKVの代わりにRDBMSを使用します。 RDBMSを使用するには、Cosmos SDK API( `KVStore`インターフェース)に大きな変更を加える必要があり、より優れたデータ抽出およびインデックス作成ソリューションを提供します。オブジェクトを1バイトのブロックとして保存する代わりに、上記のSMTで[hash(key、protobuf(object))]として状態ストレージレイヤーのテーブルにレコードとして保存できます。 RDBMSに登録されているオブジェクトがSMTに送信されたオブジェクトと同じであることを確認するには、RDBMSからオブジェクトをロードし、protobufを使用してマーシャリング、ハッシュ、およびSMT検索を実行する必要があります。

### チェーン店

モジュールを使用してデータベースをサポートできるユースケースについて説明していますが、データベースは自動的に送信されません。このモジュールは、堅牢なストレージモデルを使用する役割を果たし、__オブジェクトを保存せずにオブジェクトにコミットする_セクションで説明されている機能を使用することを選択できます。

## 参照する

+ [IAVL次は何ですか？ ](https://github.com/cosmos/cosmos-sdk/issues/7100)
+ [IAVLの概要](https://docs.google.com/document/d/16Z_hW2rSAmoyMENO-RlAhQjAG3mSNKsQueMnKpmcBv0/edit#heading=h.yd2th7x3o1iv)v0.15
+ [State Commitment and Storage Report](https://paper.dropbox.com/published/State-commitments-and-storage-review--BDvA1MLwRtOx55KRihJ5xxLbBw-KeEB7eOd11pNrZvVtqUgL3h)
+ [Celestia(LazyLedger)SMT](https://github.com/lazyledger/smt)
+ Facebook Diem(Libra)SMT [デザイン](https://developers.diem.com/papers/jellyfish-merkle-tree/2021-01-14.pdf)
+ [Trillian Revocation Transparency](https://github.com/google/trillian/blob/master/docs/papers/RevocationTransparency.pdf)、[Trillian Verizable Data Structure](https://github.com/google.trillian.blob/master/docs/papers/VerizableDataStructures.pdf)。
+設計と実装[ディスカッション](https://github.com/cosmos/cosmos-sdk/discussions/8297)。
+ [IBCチェーンとそのクライアントをアップグレードする方法](https://github.com/cosmos/ibc-go/blob/main/docs/ibc/upgrades/quick-guide.md)
+ [IBCに対するADR-40の影響](https://github.com/cosmos/ibc-go/discussions/256) 