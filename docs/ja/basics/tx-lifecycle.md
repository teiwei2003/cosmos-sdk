# トランザクションのライフサイクル

このドキュメントでは、トランザクションの作成からコミット状態の変更までのライフサイクルについて説明します。 トランザクションの定義は、[さまざまなドキュメント](../core/transactions.md)で説明されています。 このトランザクションは[Tx]と呼ばれます。 {まとめ}

### 読むための前提条件

-[Cosmos SDKアプリケーション分析](./app-anatomy.md){前提条件}

## 作成

### トランザクションの作成

主なアプリケーションプログラムインターフェイスの1つは、コマンドラインインターフェイスです。 トランザクション `Tx`は、ユーザーが[コマンドライン](../core/cli.md)から次のフォーマットコマンドを入力し、`[コマンド] `にトランザクションタイプを入力し、`[args] `にパラメータを入力することで作成できます。および `[flags]`でのガス価格の構成: 

```bash
[appname] tx[command][args][flags]
```

このコマンドは、トランザクションを自動的に**作成**し、アカウントの秘密鍵で**署名**し、指定されたピアノードに**ブロードキャスト**します。

トランザクションの作成には、いくつかの必須およびオプションのフラグがあります。 `--from`フラグは、トランザクションの発信元の[account](./accounts.md)を指定します。たとえば、取引がコインを送ることである場合、資金は指定された[差出人]アドレスから引き出されます。

#### ガソリンと経費

さらに、[fees](./gas-fees.md)で支払う意思を示すために使用できる[flags](../core/cli.md)ユーザーがいくつかあります。

-`--gas`は、コンピューティングリソースを表す `Tx`によって消費される[gas](./gas-fees.md)の量を指します。ガスはトランザクションに依存し、実行前に正確に計算されませんが、 `--gas`の値として` auto`を指定することで推定できます。
-`--gas-adjustment`(オプション)を使用して `gas`を拡張し、過小評価を回避できます。たとえば、ユーザーはガス調整を1.5に指定して、推定ガスの1.5倍を使用できます。
-`--gas-prices`は、ユーザーがガスの単位あたりに支払う意思のある金額を指定します。これは、トークンの1つ以上の金額にすることができます。たとえば、 `--gas-prices = 0.025uatom、0.025upho`は、ユーザーがガスの単位あたり0.025uatomと0.025uphoを支払う意思があることを意味します。
-`--fees`は、ユーザーが支払う意思のある合計料金を指定します。
-`--timeout-height`は、tx送信が特定の高さを超えないようにするためのブロックタイムアウトの高さを指定します。

支払った料金の最終的な価値は、ガスにガス価格を掛けたものに等しくなります。つまり、 `fees = ceil(gas * gasPrices)`です。したがって、ガス価格を使用してコストを計算することができ、その逆も可能であるため、ユーザーは2つのうちの1つのみを指定します。

その後、バリデーターは、指定または計算された[ガス価格]をローカルの[最小ガス価格]と比較することにより、トランザクションをブロックに含めるかどうかを決定します。その `ガス価格`が十分に高くない場合、 `Tx`は拒否され、ユーザーにもっと支払うように促します。

#### CLIの例

アプリケーション[app]のユーザーは、CLIで次のコマンドを入力して、[senderAddress]から[recipientAddress]に1000uatomを送信するトランザクションを生成できます。それは彼らが喜んで支払うガスの量を指定します:それは自動的に1.5倍にスケールアップされると推定され、ガスの単位あたりのガス価格は0.025uatomです。

```bash
appd tx send <recipientAddress> 1000uatom --from <senderAddress> --gas auto --gas-adjustment 1.5 --gas-prices 0.025uatom
```

#### その他のトランザクション作成方法

コマンドラインはアプリケーションと対話する簡単な方法ですが、[gRPCまたはRESTインターフェイス](../core/grpc_rest.md)またはアプリケーション開発者が定義したその他のエントリポイントを使用して[Tx]を作成することもできます。 。ユーザーの観点からは、インタラクションはユーザーが使用するWebインターフェースまたはウォレットによって異なります(たとえば、[Lunie.io](https://lunie.io/#/)を使用して `Tx`を作成し、LedgerNanoを使用しますサインを実行するS)。

## メモリプールに追加

[Tx]を受信するすべてのフルノード(Tendermintを実行)は、[ABCIメッセージ](https://tendermint.com/docs/spec/abci/abci.html#messages)を送信します。
`CheckTx`、アプリケーション層に移動して有効性を確認し、` abci.ResponseCheckTx`を受け取ります。 [Tx]がチェックに合格した場合は、ノードに保存します
[** Mempool **](https://tendermint.com/docs/tendermint-core/mempool.html#mempool)、各ノードの一意のメモリ内トランザクションプール)ブロックに含まれるのを待っています-正直なノードは無効であることが判明した場合、 `Tx`は破棄されます。コンセンサスに達する前に、ノードは着信トランザクションを継続的にチェックし、ピアにゴシップを提供します。

### チェックタイプ

ノード全体がステートレスで実行され、[CheckTx]中に[Tx]でステートフルチェックが実行されます。目的は次のとおりです。
計算の無駄を避けるために、無効なトランザクションをできるだけ早く特定して拒否します。

** _ St​​ateless _ **チェックにはノードアクセスステータスは必要ありません-ライトクライアントまたはオフラインノードは問題ありません
それら-したがって、計算コストが低くなります。ステートレス検査には、アドレスの確認が含まれます
空ではなく、負でない数、および定義で指定された他のロジックを適用します。

** _ St​​ateful _ **送信されたステータスに基づいて、トランザクションとメッセージを確認および検証します。例
関連する値が存在し、取引できるかどうかの確認を含め、住所
十分な資金があり、送信者はトランザクションを実行するための許可されているか、正しい所有権を持っています。
いつでも、フルノードには通常[複数のバージョン](../core/baseapp.md#volatile-states)があります
さまざまな目的のためのアプリケーションの内部状態。たとえば、ノードは状態を実行します
トランザクションの検証プロセスで変更が発生しましたが、最後に送信されたコピーが引き続き必要です
クエリに回答するための状態-コミットされていない変更を伴う状態で応答するべきではありません。

[Tx]を検証するために、ノード全体が[CheckTx]を呼び出します。これには、_stateless_と_stateful_が含まれます。
チェック。[`DeliverTx`](#delivertx)ステージでさらに検証が行われます。 `CheckTx`行く
[Tx]のデコードから始めて、いくつかの手順を実行します。 

### デコード

アプリケーションが基盤となるコンセンサスエンジン(Tendermintなど)から `Tx`を受信した場合、それはまだ[encoded](../core/encoding.md)`[] byte`の形式であり、処理する注文。次に、[`runTx`](../core/baseapp.md#runtx-and-runmsgs)関数を呼び出して、` runTxModeCheck`モードで実行します。これは、関数がすべてのチェックを実行するが、メッセージと書き込みステータスを実行することを意味します。前に変更を終了します。

### ValidateBasic

[`sdk.Msg`s](../core/transactions.md#messages)は` Tx`から抽出され、モジュール開発者によって実装された `sdk.Msg`インターフェースの` ValidateBasic`メソッドを実行します。 `ValidateBasic`には、基本的な**ステートレス**の健全性チェックを含める必要があります。たとえば、メッセージが1つのアドレスから別のアドレスにコインを送信する場合、[ValidateBasic]は空でないアドレスと負でないコインカウントをチェックできますが、アドレスのアカウント残高などのステータスを知る必要はありません。 。

### 前処理プログラム

ValidateBasicチェックの後、 `AnteHandler`を実行します。技術的にはオプションですが、実際には、署名の検証、ガス計算、料金控除、およびブロックチェーントランザクションに関連するその他のコア操作を実行するように見えることがよくあります。

キャッシュコンテキストのコピーが `AnteHandler`に提供され、トランザクションタイプに指定された制限付きチェックが実行されます。コピーを使用すると、AnteHandlerは、最後に送信された状態を変更せずに `Tx`のステータスを確認し、実行が失敗したときに元の状態に復元できます。

たとえば、[`auth`](https://github.com/cosmos/cosmos-sdk/tree/master/x/auth/spec)モジュール` AntiHandler`は、シリアル番号をチェックしてインクリメントし、署名とアカウント番号をチェックします、およびトランザクションから料金は最初の署名者から差し引かれます-すべての状態変更は `checkState`を使用して行われます。

### ガス

[`Context`](../core/context.md)は` GasMeter`を保存します。これは、 `Tx`の実行中に使用されたガスの量を追跡して初期化されます。 [Tx]のためにユーザーが提供するガスの量は[GasWanted]と呼ばれます。 `GasConsumed`、つまり実行中に消費されたガスの量が` GasWanted`を超えると、実行は停止し、状態キャッシュコピーに加えられた変更はコミットされません。それ以外の場合、 `CheckTx`は` GasUsed`を `GasConsumed`と等しく設定し、結果に返します。ガスとコストの値を計算した後、バリデーターノードはユーザー指定の[ガス価格]がローカルで定義された[最小ガス価格]よりも大きいかどうかをチェックします。

### メモリプールを破棄または追加する

`CheckTx`期間中に` Tx`が失敗した場合、それは破棄され、トランザクションのライフサイクルが終了します。
三。それ以外の場合、 `CheckTx`を正常に通過した場合、デフォルトのプロトコルはそれをピアに中継することです
[Tx]が次のブロックに含める候補になるように、ノードを作成してメモリプールに追加します。

** mempool **は、すべてのフルノードで見られるトランザクションを追跡するために使用されます。
すべてのノードは、最初の行として表示された最後の `mempool.cache_size`トランザクションの** mempool cache **を保持します
リプレイ攻撃を防ぐための防御。理想的には、 `mempool.cache_size`はすべてを含むのに十分な大きさです
メモリプール全体のトランザクション。 mempoolキャッシュが小さすぎて、すべてを追跡できない場合
トランザクションの場合、 `CheckTx`は、再生されたトランザクションを識別して拒否する責任があります。

現在の既存の予防策には、区別するためのコストと[シーケンス](ノンス)カウンターが含まれます
同じだが有効なトランザクションからトランザクションを再生します。攻撃者が多くを持っている場合
[Tx]のコピー、メモリプールキャッシュを保持する完全なノードは、実行する代わりに同じコピーを拒否します
それらすべての[CheckTx]。コピーに[シリアル]番号が追加されている場合でも、攻撃者は
支払う必要性に不満。

バリデーターノードは、フルノードと同様にリプレイ攻撃を防ぐためにメモリプールを予約しますが、それを次のように使用します。
ブロックに含まれる未確認のトランザクションプールを準備します。 `Tx`であっても注意してください
この段階では、すべての検査に合格していますが、後で無効になる可能性があります。
`CheckTx`はトランザクションを完全には検証しません(つまり、実際にはメッセージを実行しません)。

## ブロックに含まれる

コンセンサス、検証ノードがどのトランザクションについて合意に達するプロセス
受け入れは**ラウンド**で発生しました。すべてのラウンドは、提案者がブロックを作成することから始まります
最新のトランザクションは、投票権を持つ特別なフルノードである** Validator **で終了します。
コンセンサスに達するには、ブロックを受け入れるか、代わりに[nil]ブロックを使用することに同意します。検証ノード
[Tendermint BFT](https://tendermint.com/docs/spec/consensus/consensus.html#terms)などのコンセンサスアルゴリズムを実行します。
ABCIを使用して、コスト合意に達するためにアプリケーションにトランザクションの確認を要求します。

コンセンサスの最初のステップは**ブロック提案**です。バリデーターの1つを選択してください
コンセンサスアルゴリズムを使用してブロックを作成および提案します-[Tx]を含めるために、
この提案者のメモリプールに存在する必要があります。

## ステータスの変更

コンセンサスの次のステップは、トランザクションを実行して完全に検証することです。すべてのフルノード
正しい提案者からブロック提案を受け取った人は、ABCI関数を呼び出してトランザクションを実行します
[`BeginBlock`](./app-anatomy.md#beginblocker-and-endblocker)、各トランザクションの` DeliverTx`、
そして[`EndBlock`](./app-anatomy.md#beginblocker-and-endblocker)。すべてのフルノードがすべてを実行しますが
メッセージの状態遷移は決定論的であり、トランザクションは次のようになるため、ローカルでは、このプロセスは単一の明確な結果を生成します。
ブロック提案を明確に分類します。  

```
		-----------------------
		|Receive Block Proposal|
		-----------------------
		          |
			  v
		-----------------------
		| BeginBlock	      |
		-----------------------
		          |
			  v
		-----------------------
		| DeliverTx(tx0)      |
		| DeliverTx(tx1)      |
		| DeliverTx(tx2)      |
		| DeliverTx(tx3)      |
		|	.	      |
		|	.	      |
		|	.	      |
		-----------------------
		          |
			  v
		-----------------------
		| EndBlock	      |
		-----------------------
		          |
			  v
		-----------------------
		| Consensus	      |
		-----------------------
		          |
			  v
		-----------------------
		| Commit	      |
		-----------------------
```

### DeliverTx

[`BaseApp`](../core/baseapp.md)で定義された` DeliverTx`ABCI関数はほとんどの
状態遷移:送信順にブロック内のトランザクションごとに実行
コンセンサス期間中。舞台裏では、 `DeliverTx`は` CheckTx`とほとんど同じですが、
[`runTx`](../core/baseapp.md#runtx)は、チェックモードではなく配信モードで実行されます。
フルノードは `checkState`を使用せず、代わりに` deliverState`を使用します。

-**デコード:** `DeliverTx`はABCI呼び出しであるため、` Tx`はエンコードされた `[] byte`の形式で受信されます。
  ノードは最初にトランザクションをアンマーシャリングし、アプリケーションで定義された[`TxConfig`](./app-anatomy#register-codec)を使用してから、` runTxModeDeliver`で `runTx`を呼び出します。これは` CheckTx`と非常によく似ていますが、また、ステータス変更の実行と書き込みも行います。

-**チェック:**すべてのノードが `validateBasicMsgs`と` AnteHandler`を再度呼び出します。 2回目のチェック
  その理由は、Mempoolステージへの追加中に同じトランザクションが表示されない可能性があるためです\
  また、悪意のある提案者には、無効な提案者が含まれる場合があります。ここでの1つの違いは
  値がローカルであるため、 `AnteHandler`は` gas-prices`をノードの `min-gas-prices`と比較しません
  各ノードに対して-ノード間で値が異なると、不確実な結果が生成されます。

-** `MsgServiceRouter`:**` CheckTx`は終了しますが、 `DeliverTx`は引き続き実行されます
 [`runMsgs`](../core/baseapp.md#runtx-and-runmsgs)トランザクション内の各` Msg`を完全に実行します。
  トランザクションには異なるモジュールからのメッセージが含まれる可能性があるため、BaseAppはどのモジュールを知る必要があります
  適切な処理プログラムを見つけてください。これは、 `BaseApp`の` MsgServiceRouter`を使用して実装されるため、モジュールのProtobuf[`Msg`サービス](../building-modules/msg-services.md)で処理できます。
  `LegacyMsg`ルートの場合、` Route`関数は[modulemanager](../building-modules/module-manager.md)によって呼び出され、ルート名を取得してレガシー[`Handler`](。。モジュール内の/building-modules/msg-services.md#handler-type)。

-** `Msg`サービス:** Protobuf`Msg`サービスは` AnteHandler`のステップであり、それぞれの実行を担当します
  `Tx`のメッセージにより、状態遷移が` deliverTxState`に保持されます。

-** Gas​​:** `Tx`を配信するときは、` GasMeter`を使用して量を追跡します
  ガスが使用されています。実行が完了すると、 `GasUsed`が設定され、
  `abci.ResponseDeliverTx`。 `BlockGasMeter`または` GasMeter`が使い果たされたなどの理由で実行が停止された場合
  間違って、最後の遅延機能が適切に間違っているか、パニックになっています。

無効な[Tx]または[GasMeter]の枯渇が原因で失敗した状態変更がある場合、
トランザクションは終了し、状態の変化はすべて復元されます。無効なトランザクション
ブロック提案により、バリデーターノードはブロックを拒否し、代わりに[nil]ブロックに投票します。

### 犯罪

最後のステップは、ノードがブロックと状態の変更をコミットすることです。検証ノード
前のステップで状態遷移を実行して、トランザクションを検証します。
次に、ブロックに署名して確認します。バリデーターではないフルノードは
コンセンサスに参加する-つまり、投票することはできません-しかし、投票に耳を傾けて、
ステータスの変更を送信しないでください。

バリデーターから十分な票を受け取ると(投票権によって重み付けされた2/3以上の_precommits_)、ノード全体が新しいブロックを送信してブロックチェーンに追加し、
アプリケーション層で状態遷移を完了します。次のように新しい状態ルートを生成します
状態遷移のメルケル証明。アプリケーション使用[`Commit`](../core/baseapp.md#commit)
ABCIメソッドは[Baseapp](../core/baseapp.md)から継承され、次のようにすべての状態遷移を同期します。
アプリケーションの内部状態に `deliverState`を書き込みます。状態が変化したら
送信されると、 `checkState`は最後に送信された状態と` deliverState`から再開します
一貫性を保ち、変更を反映するには、 `nil`にリセットします。

すべてのブロックが同じ数のトランザクションを持っているわけではなく、コンセンサスに達する可能性があることに注意してください
nilブロックまたはまったく存在しないブロックを引き起こします。パブリックブロックチェーンネットワークでは、それも可能です
ベリファイアは**ビザンチン**または悪意のあるものであり、[Tx]が
ブロックチェーン。考えられる悪意のある動作には、次の方法で[Tx]を確認するという提案者の決定が含まれます。
ブロックまたはブロックに反対票を投じたバリデーターから除外します。

この時点で、[Tx]トランザクションのライフサイクルは終了します。ノードはその有効性を検証し、
状態の変更を実行して配信し、これらの変更をコミットします。 `Tx`自体、
`[] byte`の形式でブロックに格納され、ブロックチェーンにアタッチされます。

## 次へ{hide}

[accounts](./accounts.md)を理解する{hide} 